# 算法地图（Algorithm Map）— 愿景

## 一句话

面向 AI 时代的算法管理框架：让不写代码的人能可靠地驾驭复杂代码。

## 问题

AI（如 Claude Code）已经能写出几千行甚至上万行的复杂算法代码。但一个新问题出现了：

**代码写出来了，你怎么知道它是对的？**

如果你本身不擅长底层代码（比如 C++），你面临的困境是：
- 代码太长太复杂，看不懂
- 出了 bug 让 AI 改，AI 也不一定能精确定位
- 反复调试，效率极低

你需要一个**不在代码层面的抓手**来管理整件事。

## 核心洞察

**不看代码，看验证。验证通过 = 代码可信。**

把复杂算法拆成环节，为每个环节定义清晰的验证标准（前置条件、内部正确性、后置条件）。所有验证通过 = 整条链路可信。任何验证失败 = 精确定位到出问题的环节。

## 什么是算法地图

一张交互式的算法流程图，两层结构：

- **第一层（全局）**：流程图，显示算法的所有步骤和流转关系
- **第二层（细节）**：点开任意步骤，看到 6 个维度的详细信息

这张图**不是一个静态文档**，它是一个活的工具，贯穿项目全生命周期。

## 三个阶段

### 阶段一：施工蓝图（Plan）

代码还没写。你和 AI 协商算法结构：
- 画出流程图：哪些步骤、什么顺序、哪里循环、哪里分支
- 填写概述：每步做什么、为什么
- **定义验证标准**：每步怎么确认是对的（这是核心）
- 你审核、批注、讨论、迭代，直到满意

这个阶段的输出就是 plan。**图就是 plan。**

### 阶段二：施工现场（Build）

按图施工：
- AI 逐环节写代码
- 每写完一个环节，跑该环节的验证
- 验证通过，标记绿色，继续下一个
- 验证失败，就在这个环节排查，不用翻几千行代码找问题
- 过程中填充 Code、参考资料、踩坑记录

### 阶段三：成品交付物（Deliver）

所有环节验证通过后，这张图自动变成一份完整的算法文档：
- 流程图 → 算法结构
- 概述 + How → 算法说明
- Verify → 质量证据
- Code → 源码索引
- 参考 → 知识积累
- 踩坑 → 经验总结

可用于汇报、论文、PPT、团队交接。

## 为什么比传统 plan 好

| | CC 默认 plan | 算法地图 |
|---|---|---|
| 形式 | 文字清单 | 交互式流程图 |
| 结构 | 线性 | 支持分支、循环、并行 |
| 验证 | 无 | 三层验证（前置/核心/后置） |
| 接口契约 | 无 | 后置条件 ↔ 前置条件链式对应 |
| 可审核 | 列完就开干 | 可批注、讨论、反复迭代 |
| 生命周期 | 一次性 | plan → 施工指导 → 成品文档 |
| 并行 | 需要额外规划 | 图的依赖关系天然定义了并行结构 |

## 关键机制

### 1. 图替代代码（工作界面）

你的工作界面不是 IDE，不是代码编辑器，是这张图。你通过图理解算法、审核进度、定位问题。

### 2. 验证替代阅读（信任手段）

你不需要读懂每一行代码。你只需要确认验证通过。验证标准是你和 AI 在规划阶段共同定义的，你理解也认可的。

### 3. 三层验证形成链式信任

```
环节 A 后置条件: "输出 X 满足条件 P"
        ‖
环节 B 前置条件: "输入 X 满足条件 P"
```

每个环节验证通过就像盖了一个章。全部盖章 = 整条链路可信。

### 4. 流程图天然定义并行

没有依赖关系的节点可以同时开发。每个并行分支可以分配给一个子代理。子代理的任务边界和验收标准都由图定义。

### 5. 双层批注支持审核

- 流程图层面：批注结构问题（"这里应该加一步""这条边方向不对"）
- 面板层面：批注内容问题（"这个验证标准不够严格""这个解释不对"）

### 6. 迭代修改保留状态

规划不是一次性的。中间发现设计有问题，可以调整图的结构，已有的验证状态和批注不会丢失。

## 提升 AI 能力上限

这张图不是让 AI 变聪明了，而是通过结构化拆解和逐步验证，让 AI 能**可靠地**处理更复杂的问题。

AI 的瓶颈不是智力，是上下文窗口。一次性想清楚万行代码的所有细节，它做不到。但在一个清晰的框架内，一次只实现一个环节，每个环节有明确的验证标准——这个它能做到。

```
没有图：AI 写万行代码 → 到处出错 → 难以排查
有图：  AI 写十个模块 × 每个千行 → 逐个验证 → 错误早期拦截
```

## 双视图架构

这张图有两个读者，需求完全不同：

```
人：看渲染后的交互式流程图，视觉直觉，一眼全局
AI：读结构化数据，逻辑推理，恢复上下文
```

所以同一份数据应该有两种呈现，双向同步：

```
algorithm-map.json（AI 视图）⟺ algorithm-map.html（人类视图）
```

### JSON（给 AI）

纯数据，几百行，包含：
- 图结构：节点、边、分组
- 每个节点的 6 个 Tab 内容
- 当前状态：验证打勾情况、节点进度
- 批注内容（流程图批注 + 面板批注）

AI 开新对话时读这个文件，几秒钟恢复完整项目上下文。不需要人手动交代"我们做到哪了"。

### HTML（给人）

交互式页面，包含：
- 可点击的流程图
- 右侧面板（6 个 Tab）
- 批注系统
- 进度追踪

### 双向同步

```
你在 HTML 里打勾、批注 → 状态同步到 JSON
AI 更新 JSON（开发新环节、填充内容）→ 重新渲染 HTML
```

### 为什么重要

图就是项目的记忆。AI 没有跨对话记忆，但 JSON 文件是持久的。每次新对话读 JSON = 恢复记忆。

这解决了复杂项目跨越多轮对话、持续数周的连续性问题。

## 知识获取管线

当 AI 不懂某个环节时，验证体系再好也没用——它得先知道怎么做。知识获取是算法地图的重要配套能力。

### 瓶颈

- 论文有付费墙，搜得到但下载不了
- 一篇论文几十页，PDF 中的公式直接读取会乱码丢失
- 上下文窗口有限，几篇论文就塞满了
- 关键知识分散在多个来源

### 分层知识获取

```
第一层：公开知识（成本最低，优先使用）
  → 搜索网页、博客、GitHub 代码、StackOverflow
  → 大多数情况够用

第二层：论文调研（精准定位）
  → 搜索论文标题和摘要
  → 通过摘要筛选出最相关的 3-5 篇（严格控制数量）
  → 摘要调研是关键——用最小成本判断每篇的价值

第三层：论文精读（子代理并行）
  → 下载 PDF
  → PDF 转 MD（关键步骤：保留公式为 LaTeX 格式，避免公式丢失）
  → 每篇论文派一个子代理，带着明确问题精读 MD
  → 子代理返回提炼后的关键知识（几百字，不是全文）
  → 汇总后填入对应环节的 Refs tab
```

### 为什么要 PDF → MD

PDF 中的数学公式直接提取会出现：
- 公式变成乱码或图片无法识别
- 上下标丢失
- 希腊字母变成错误字符

转成 MD 后公式保留为 LaTeX 格式（如 `$\sum_{i} \pi_i a_{ir}$`），AI 能准确理解数学含义。

### 与算法地图的对接

```
地图环节4（定价子问题）
  → AI 标记："标签 dominance 规则的实现细节不确定"
  → 第一层：搜公开资料，找到大概思路
  → 第二层：搜论文摘要，筛出 3 篇
  → 第三层：
     下载 3 篇 PDF → 各自转 MD
     子代理 A 读论文1："找 dominance 规则的数学定义"
     子代理 B 读论文2："找实现加速技巧"
     子代理 C 读论文3："找边界情况处理"
  → 三个子代理的输出汇总 → 填入环节4的 Refs tab
  → 主代理带着这些知识实现环节4
```

### 核心原则

1. **分层过滤**：不是上来就下论文，先用免费信息尽量解决
2. **严控数量**：论文不超过 5 篇，多了上下文也装不下
3. **带着问题读**：子代理不是通读全文，是带着具体问题找答案
4. **知识沉淀**：获取的知识填入 Refs tab，后续复用

## 本质

人天然喜欢图，因为图是空间性的，能同时看到全局和局部。代码是线性的，但算法的逻辑结构不是线性的。图把非线性结构还原了。

这张图做的事情，就是人面对复杂问题时自然会做的事情：
1. 先画个框架
2. 看哪里不对，改一改
3. 确认框架对了，开始细化
4. 做完一块确认一块
5. 最后整体检查

只不过我们用工具把这个自然过程固化了，并且加上了严格的验证体系。

## 独特性

这个工具的目标用户不是程序员，而是**驾驭 AI 写代码的人**。这个角色在 AI 编程之前不存在。他需要的不是"怎么写代码"，而是"怎么确认 AI 写的代码是对的"。

现有工具要么面向程序员（TDD、CI/CD），要么只是静态图（Mermaid、draw.io），要么是低代码平台（面对复杂算法力不从心）。算法地图填补了这个空白。

## 工作架构：图作为人机通信协议

### 多终端并行 + 智能总管

```
你（决策者）
 ↕  只在关键节点交互：审核图、批注、确认
智能总管
 ↕  ↕  ↕  ↕  日常代理所有终端交互
CC终端1   CC终端2   CC终端3   CC终端4
(环节1-3) (环节4-5) (环节6-7) (环节8-9)
```

### 你的工作只有三件事

1. **审核图**：总管提交图给你，你看流程和验证标准
2. **批注图**：哪里不对直接在图上标注
3. **一键反馈**：批注完提交，总管分发给对应终端

你不跟任何终端直接对话，不看任何代码，不看大部分中间过程。你只和图交互。

### 图是唯一的通信界面

```
传统：人 ↔ 代码
现在：人 ↔ 图 ↔ AI 系统（总管 + 多终端）
```

- 你的意图通过**批注**传下去
- AI 的进度通过**状态**传上来
- 知识通过 **Refs/踩坑** 在环节间流动
- 验证结果通过**打勾**实时可见

图不只是文档或 plan，它是整个人机协作系统的**协议层**。

### 总管的角色

智能总管代替你处理日常交互：
- 分配任务给各终端（根据图的依赖关系）
- 监控各环节的验证状态
- 处理简单问题（环境配置、依赖安装等）
- **只有关键决策提交给你**：图的结构变更、验证标准调整、重大 bug

这样你的注意力只花在最有价值的地方：确保方向正确。

## 已实现

以上愿景不只是纸上谈兵。截至 2026 年 2 月，以下部分已经从想法变成了可工作的实现：

### 数据协议（Schema）

JSON Schema 定义了算法地图的标准数据格式，三层分离已落地：
- **graph**（结构层）：节点、边、区域分组
- **contents**（内容层）：六维信息（overview / how / verify / code / refs / pitfalls）
- **state**（状态层）：节点执行状态 + 验证结果

BPC（Branch-Price-Cut）算法作为参考实现，完整的 JSON 示例包含 13 个节点、9 个 process 节点的详细六维内容和三层验证体系。

### 交互式渲染器

单 HTML 文件，零安装依赖，读取任意符合 schema 的 JSON 即可渲染：
- dagre 自动布局 + 形状裁剪（菱形、椭圆精确连线）
- 点击节点展开右侧六维面板，Markdown 和 KaTeX 公式实时渲染
- 进度条 + 节点状态点（灰/黄/蓝/紫/绿 五色）
- 验证结果只读展示（由自动化流程写入，不允许手动勾选）

### 批注系统 + 反馈桥

双层批注已实现：
- 流程图层面：点击节点/边添加结构性批注
- 面板层面：选中文字添加内容性批注
- 一键「提交反馈」→ 汇总为精简 Markdown → POST 到 server.py 写入 `.feedback.md`
- AI 直接读 `.feedback.md`，按节点定位修改，无需人工转述
- 纯静态服务器降级：POST 失败时 fallback 到剪贴板复制

### 生成规范 + 执行规范

两份 prompt 规范让 AI 能端到端使用算法地图：
- **生成规范**（generate-map.md）：5 步流程引导 AI 从零生成合规 JSON，包含链式信任自检
- **执行规范**（execute-map.md）：单节点执行循环（理解→实现→验证→状态更新），支持断点续做

### CC 技能 `/map`

包装为 Claude Code 技能，三个子命令：
- `/map plan` — 按生成规范对话式生成地图 JSON
- `/map build` — 按执行规范逐节点实现 + 验证
- `/map view` — 启动服务器，浏览器查看进度

### 尚未实现

- 多终端并行执行（需要 CC Commander 集成）
- 知识获取管线（论文 PDF → MD 自动化）
- 地图版本控制（diff / merge）
- 子代理任务分配

这些是 Phase 2-3 的内容。当前已实现的部分足以在单终端场景下完成「规划→实施→验证」的完整闭环。

## 范式意义

一个根本性变化正在发生：**写代码的不再是人，但为代码负责的还是人。**

以前所有的软件工程工具——IDE、调试器、代码审查、测试框架——都假设使用者能读懂代码。这个假设不再成立。

算法地图回答的问题是：**如果人不读代码了，人和代码之间的接口应该是什么？**

答案：结构化的验证体系，以图的形式呈现，同时服务人和 AI。

这可能是一种新的范式：

- 人通过**图**理解和管理复杂系统，而不是通过代码
- AI 通过**结构化数据**获得任务框架和项目记忆，而不是通过自然语言描述
- 质量通过**分层验证**保证，而不是通过人工审查代码
- 复杂度通过**图的分解**和**并行子代理**来征服，而不是靠单一智能体的能力上限

算法地图不只是一个工具，它定义了一种人和 AI 协作完成复杂工程的工作方式。
